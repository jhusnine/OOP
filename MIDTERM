from abc import ABC, abstractmethod

class Wallet(ABC):
    def __init__(self, balance=0.0):
        self.__Wallet_balance = balance

    @abstractmethod
    def transaction(self, transaction_type, amount):
        pass

    @property
    def balance(self):
        return __Wallet_balance

class BitcoinWallet(Wallet):
    def __init__(self, balance=0.0):
        super().__init__(balance)

    def transaction(self, transaction_type, amount):
        if transaction_type == "buy":
            self.__Wallet_balance += amount
        elif transaction_type == "sell" and self.__Wallet_balance >= amount:
            self.__Wallet_balance -= amount
        else:
            print("Invalid transaction or insufficient balance!")

class EthereumWallet(Wallet):
    def __init__(self, balance=0.0):
        super().__init__(balance)

    def transaction(self, transaction_type, amount):
        if transaction_type == "buy":
            self.__Wallet_balance += amount
        elif transaction_type == "sell" and self.__Wallet_balance >= amount:
            self.__Wallet_balance -= amount
        else:
            print("Invalid transaction or insufficient balance!")

alice_wallet = BitcoinWallet(0.5)
bob_wallet = EthereumWallet(2.0)

print("Bitcoin Wallet for Alice")
print(f"Initial Balance: {alice_wallet.balance} BTC")
alice_wallet.transaction("buy", 0.2) 
print(f"Performing Transaction: Buy 0.2 BTC")
print(f"New Balance: {alice_wallet.balance} BTC\n")

print("Ethereum Wallet for Bob")
print(f"Initial Balance: {bob_wallet.balance} ETH")
bob_wallet.transaction("sell", 1.0)
print(f"Performing Transaction: Sell 1.0 ETH")
print(f"New Balance: {bob_wallet.balance} ETH")
