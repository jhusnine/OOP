from abc import ABC, abstractmethod

class Wallet(ABC):
    def __init__(self, balance=0.0):
        self._balance = balance  # Change from __balance to _balance for protected

    @abstractmethod
    def transaction(self, transactionType, amount):
        pass

    @property
    def balance(self):
        return self._balance  # Expose balance as a property

    def _update_balance(self, amount):
        self._balance = amount  # Update the balance using protected attribute

class BitcoinWallet(Wallet):
    def __init__(self, balance=0.0):
        super().__init__(balance)

    def transaction(self, transactionType, amount):
        if transactionType == "buy":
            self._update_balance(self.balance + amount)
        elif transactionType == "sell" and self.balance >= amount:
            self._update_balance(self.balance - amount)
        else:
            print("Invalid transaction or insufficient balance!")

class EthereumWallet(Wallet):
    def __init__(self, balance=0.0):
        super().__init__(balance)

    def transaction(self, transaction_type, amount):
        if transaction_type == "buy":
            self._update_balance(self.balance + amount)
        elif transaction_type == "sell" and self.balance >= amount:
            self._update_balance(self.balance - amount)
        else:
            print("Invalid transaction or insufficient balance!")

Alice = BitcoinWallet(0.5)
Bob = EthereumWallet(2.0)

print("Bitcoin Wallet for Alice")
print(f"Initial Balance: {Alice.balance} BTC")
Alice.transaction("buy", 0.2)
print(f"Performing Transaction: Buy 0.2 BTC")
print(f"New Balance: {Alice.balance} BTC\n")
